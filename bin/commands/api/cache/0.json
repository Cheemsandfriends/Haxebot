{"size":26,"fields":{"h":{"h2d.Tile.fromPixels":{"id":"fromPixels","code":"static fromPixels(pixels:Pixels):Tile","doc":"Creates new POT Texture from Pixels and returns a Tile representing it. "},"h2d.Tile.fromTexture":{"id":"fromTexture","code":"static fromTexture(t:Texture):Tile","doc":"Create new Tile from provided Texture instance. "},"h2d.Tile.x":{"id":"x","code":"read only x:Float","doc":"Horizontal position of the Tile on the Texture. Cannot be modified directly, use Tile.setPosition instead. "},"h2d.Tile.xFlip":{"id":"xFlip","code":"xFlip:Bool","doc":"The flip state of the Tile. "},"h2d.Tile.flipX":{"id":"flipX","code":"flipX:Void","doc":"Flips the Tile horizontally. Note that dx is flipped as well. "},"h2d.Tile.dx":{"id":"dx","code":"dx:Float","doc":"Visual offset of the Tile along the X axis during rendering. "},"h2d.Tile.ix":{"id":"ix","code":"read only ix:Int","doc":"An integer horizontal position of the Tile on the Texture.Alias to Math.floor(tile.x). "},"h2d.Tile.getTexture":{"id":"getTexture","code":"inline getTexture:Texture","doc":"Returns an underlying Texture instance. "},"h2d.Tile.switchTexture":{"id":"switchTexture","code":"inline switchTexture:Void","doc":"Changes this Tile underlying texture to one used in the specified Tile. If Tile was scaled, new uv will cover new width and height instead of the original unscaled one. @:privateAccess tile.setTexture(myTextureInstance); "},"flixel.FlxBasic.draw":{"id":"draw","code":"draw():Void","doc":"Override this function to control how the object is drawn.Doing so is rarely necessary, but can be very useful. "},"flixel.FlxBasic.destroy":{"id":"destroy","code":"destroy():Void","doc":"WARNING: A destroyed FlxBasic can't be used anymore.It may even cause crashes if it is still part of a group or state.You may want to use kill() instead if you want to disable the object temporarily only and revive() it later. This function is usually not called manually (Flixel calls it automatically during state switches for all add()ed objects). Override this function to null out variables manually or call destroy() on class members if necessary.Don't forget to call super.destroy()! "},"flixel.FlxBasic.ID":{"id":"ID","code":"ID:Int = idEnumerator++","doc":"A unique ID starting from 0 and increasing by 1 for each subsequent FlxBasic that is created. "},"flixel.FlxBasic.update":{"id":"update","code":"update(elapsed:Float):Void","doc":"Override this function to update your class's position and appearance.This is where most of your game rules and behavioral code will go. "},"h2d.Graphics.lineTo":{"id":"lineTo","code":"inline lineTo(x:Float, y:Float):Void","doc":"Draws a straight line from the current drawing position to the given position. "},"h2d.Graphics.lineStyle":{"id":"lineStyle","code":"lineStyle(size:Float = 0, color:Int = 0, alpha:Float = 1.):Void","doc":"Sets an outline style. Changing the line style ends the currently drawn line. "},"h2d.Graphics.localToGlobal":{"id":"localToGlobal","code":"localToGlobal:Point","doc":"Convert a local position (or [0,0] if pt is null) relative to the object origin into an absolute screen position, applying all the inherited transforms. "},"h2d.Graphics.globalToLocal":{"id":"globalToLocal","code":"globalToLocal:Point","doc":"Convert an absolute screen position into a local position relative to the object origin, applying all the inherited transforms. "},"h2d.Graphics.clear":{"id":"clear","code":"clear:Void","doc":"Clears the Graphics contents. "},"h2d.Graphics.alpha":{"id":"alpha","code":"alpha:Float = 1.","doc":"The amount of transparency of the Object. "},"h2d.Graphics.blendMode":{"id":"blendMode","code":"blendMode:BlendMode = Alpha","doc":"The blending mode of the object. If there is no Object.filter active, only applies to the current object (not inherited by children).Otherwise tells how the filter is blended with background. "},"h2d.Graphics.allocated":{"id":"allocated","code":"private allocated:Bool","doc":"A flag that indicates whether the object was allocated or not. When adding children to allocated objects, onAdd is being called immediately,otherwise it's delayed until the whole tree is added to a currently active Scene. "},"h2d.Graphics.clipBounds":{"id":"clipBounds","code":"private Internal usage clipBounds:","doc":""},"h2d.Graphics.tile":{"id":"tile","code":"tile:Tile","doc":"The Tile used as source of Texture to render. "},"js.lib.Promise.catch":{"id":"catch","code":"catch\")","doc":"Appends a rejection handler callback to the promise, and returns a newpromise resolving to the return value of the callback if it is called,or to its original fulfillment value if the promise is instead fulfilled. "},"js.lib.Promise.race":{"id":"race","code":"static race(iterable:Array<Dynamic>):Promise<Dynamic>","doc":"Returns a promise that fulfills or rejects as soon as one of thepromises in the iterable fulfills or rejects, with the value or reasonfrom that promise. "},"js.lib.Promise.reject":{"id":"reject","code":"static reject<T>(?reason:Dynamic):Promise<T>","doc":"Returns a Promise object that is rejected with the given reason. "}}}}