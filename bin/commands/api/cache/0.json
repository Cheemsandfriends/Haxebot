{
	"size": 3,
	"fields": {
		"h": {
			"Array.concat": {
				"id": "concat",
				"code": "concat(a:Array<T>):Array<T>",
				"doc": "Returns a new Array by appending the elements of a to the elements ofthis Array. This operation does not modify this Array. If a is the empty Array [], a copy of this Array is returned. The length of the returned Array is equal to the sum of this.lengthand a.length. If a is null, the result is unspecified. "
			},
			"flixel.FlxG.collide": {
				"id": "collide",
				"code": "static inline | collide(?ObjectOrGroup1:FlxBasic, ?ObjectOrGroup2:FlxBasic, ?NotifyCallback:(Dynamic, Dynamic) ‑> Void):Bool",
				"doc": "Call this function to see if one FlxObject collides with another within FlxG.worldBounds.Can be called with one object and one group, or two groups, or two objects,whatever floats your boat! For maximum performance try bundling a lot of objectstogether using a FlxGroup (or even bundling groups together!). This function just calls FlxG.overlap and presets the ProcessCallback parameter to FlxObject.separate.To create your own collision logic, write your own ProcessCallback and use FlxG.overlap to set it up.NOTE: does NOT take objects' scrollFactor into account, all overlaps are checked in world space. "
			},
			"Array.indexOf": {
				"id": "indexOf",
				"code": "indexOf(x:T, ?fromIndex:Int):Int",
				"doc": "Returns position of the first occurrence of x in this Array, searching front to back. If x is found by checking standard equality, the function returns its index. If x is not found, the function returns -1. If fromIndex is specified, it will be used as the starting index to search from,otherwise search starts with zero index. If it is negative, it will be taken as theoffset from the end of this Array to compute the starting index. If given or computedstarting index is less than 0, the whole array will be searched, if it is greater thanor equal to the length of this Array, the function returns -1. "
			}
		}
	}
}